// Code generated by cmd/cgo; DO NOT EDIT.

//line /data/data/com.termux/files/home/go/pkg/mod/github.com/smacker/go-tree-sitter@v0.0.0-20230720070738-0d0a9f78d8f8/bindings.go:1:1
package sitter; import _cgo_unsafe "unsafe"

// #include "bindings.h"
import _ "unsafe"

import (
	"context"
	"errors"
	"fmt"
	"math"
	"reflect"
	"regexp"
	"runtime"
	"strings"
	"sync"
	"sync/atomic"
	"unsafe"
)

// maintain a map of read functions that can be called from C
var readFuncs = &readFuncsMap{funcs: make(map[int]ReadFunc)}

// Parse is a shortcut for parsing bytes of source code,
// returns root node
//
// Deprecated: use ParseCtx instead
func Parse(content []byte, lang *Language) *Node {
	n, _ := ParseCtx(context.Background(), content, lang)
	return n
}

// ParseCtx is a shortcut for parsing bytes of source code,
// returns root node
func ParseCtx(ctx context.Context, content []byte, lang *Language) (*Node, error) {
	p := NewParser()
	p.SetLanguage(lang)
	tree, err := p.ParseCtx(ctx, nil, content)
	if err != nil {
		return nil, err
	}

	return tree.RootNode(), nil
}

// Parser produces concrete syntax tree based on source code using Language
type Parser struct {
	isClosed bool
	c        * /*line :48:12*/_Ctype_TSParser /*line :48:22*/
	cancel   *uintptr
}

// NewParser creates new Parser
func NewParser() *Parser {
	cancel := uintptr(0)
	p := &Parser{c: ( /*line :55:18*/_Cfunc_ts_parser_new /*line :55:32*/)(), cancel: &cancel}
	func() { _cgo0 := /*line :56:36*/p.c; var _cgo1 *_Ctype_size_t = /*line :56:41*/(*_Ctype_size_t /*line :56:51*/)(unsafe.Pointer(p.cancel)); _cgoCheckPointer(_cgo0, nil); /*line :56:79*/_Cfunc_ts_parser_set_cancellation_flag(_cgo0, _cgo1); }()
	runtime.SetFinalizer(p, (*Parser).Close)
	return p
}

// SetLanguage assignes Language to a parser
func (p *Parser) SetLanguage(lang *Language) {
	cLang := (* /*line :63:13*/_Ctype_struct_TSLanguage /*line :63:32*/)(lang.ptr)
	func() _Ctype__Bool{ _cgo0 := /*line :64:27*/p.c; _cgo1 := /*line :64:32*/cLang; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :64:38*/_Cfunc_ts_parser_set_language(_cgo0, _cgo1); }()
}

// ReadFunc is a function to retrieve a chunk of text at a given byte offset and (row, column) position
// it should return nil to indicate the end of the document
type ReadFunc func(offset uint32, position Point) []byte

// InputEncoding is a encoding of the text to parse
type InputEncoding int

const (
	InputEncodingUTF8 InputEncoding = iota
	InputEncodingUTF16
)

// Input defines parameters for parse method
type Input struct {
	Read     ReadFunc
	Encoding InputEncoding
}

var (
	ErrOperationLimit = errors.New("operation limit was hit")
	ErrNoLanguage     = errors.New("cannot parse without language")
)

// Parse produces new Tree from content using old tree
//
// Deprecated: use ParseCtx instead
func (p *Parser) Parse(oldTree *Tree, content []byte) *Tree {
	t, _ := p.ParseCtx(context.Background(), oldTree, content)
	return t
}

// ParseCtx produces new Tree from content using old tree
func (p *Parser) ParseCtx(ctx context.Context, oldTree *Tree, content []byte) (*Tree, error) {
	var BaseTree * /*line :100:16*/_Ctype_TSTree /*line :100:24*/
	if oldTree != nil {
		BaseTree = oldTree.c
	}

	parseComplete := make(chan struct{})

	// run goroutine only if context is cancelable to avoid performance impact
	if ctx.Done() != nil {
		go func() {
			select {
			case <-ctx.Done():
				atomic.StoreUintptr(p.cancel, 1)
			case <-parseComplete:
				return
			}
		}()
	}

	input := func() _cgo_unsafe.Pointer{ _cgo0 := /*line :119:20*/content; _cgoCheckPointer(_cgo0, nil); return /*line :119:28*/_Cfunc_CBytes(_cgo0); }()
	BaseTree = func() *_Ctype_struct_TSTree{ _cgo0 := /*line :120:38*/p.c; _cgo1 := /*line :120:43*/BaseTree; var _cgo2 *_Ctype_char = /*line :120:53*/(*_Ctype_char /*line :120:61*/)(input); var _cgo3 _Ctype_uint32_t = _Ctype_uint32_t /*line :120:81*/(len(content)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :120:96*/_Cfunc_ts_parser_parse_string(_cgo0, _cgo1, _cgo2, _cgo3); }()
	close(parseComplete)
	func() { _cgo0 := /*line :122:9*/input; _cgoCheckPointer(_cgo0, nil); /*line :122:15*/_Cfunc_free(_cgo0); }()

	return p.convertTSTree(ctx, BaseTree)
}

// ParseInput produces new Tree by reading from a callback defined in input
// it is useful if your data is stored in specialized data structure
// as it will avoid copying the data into []bytes
// and faster access to edited part of the data
func (p *Parser) ParseInput(oldTree *Tree, input Input) *Tree {
	t, _ := p.ParseInputCtx(context.Background(), oldTree, input)
	return t
}

// ParseInputCtx produces new Tree by reading from a callback defined in input
// it is useful if your data is stored in specialized data structure
// as it will avoid copying the data into []bytes
// and faster access to edited part of the data
func (p *Parser) ParseInputCtx(ctx context.Context, oldTree *Tree, input Input) (*Tree, error) {
	var BaseTree * /*line :141:16*/_Ctype_TSTree /*line :141:24*/
	if oldTree != nil {
		BaseTree = oldTree.c
	}

	funcID := readFuncs.register(input.Read)
	BaseTree = func() *_Ctype_struct_TSTree{ _cgo0 := /*line :147:36*/p.c; _cgo1 := /*line :147:41*/BaseTree; var _cgo2 _Ctype_int = _Ctype_int /*line :147:56*/(funcID); var _cgo3 _Ctype_TSInputEncoding = _Ctype_TSInputEncoding /*line :147:83*/(input.Encoding); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :147:100*/_Cfunc_call_ts_parser_parse(_cgo0, _cgo1, _cgo2, _cgo3); }()
	readFuncs.unregister(funcID)

	return p.convertTSTree(ctx, BaseTree)
}

// convertTSTree converts the tree-sitter response into a *Tree or an error.
//
// tree-sitter can fail for 3 reasons:
// - cancelation
// - operation limit hit
// - no language set
//
// We check for all those conditions if ther return value is nil.
// see: https://github.com/tree-sitter/tree-sitter/blob/7890a29db0b186b7b21a0a95d99fa6c562b8316b/lib/include/tree_sitter/api.h#L209-L246
func (p *Parser) convertTSTree(ctx context.Context, tsTree * /*line :162:61*/_Ctype_TSTree /*line :162:69*/) (*Tree, error) {
	if tsTree == nil {
		if ctx.Err() != nil {
			// reset cancellation flag so the parse can be re-used
			atomic.StoreUintptr(p.cancel, 0)
			// context cancellation caused a timeout, return that error
			return nil, ctx.Err()
		}

		if func() *_Ctype_struct_TSLanguage{ _cgo0 := /*line :171:27*/p.c; _cgoCheckPointer(_cgo0, nil); return /*line :171:31*/_Cfunc_ts_parser_language(_cgo0); }() == nil {
			return nil, ErrNoLanguage
		}

		return nil, ErrOperationLimit
	}

	return p.newTree(tsTree), nil
}

// OperationLimit returns the duration in microseconds that parsing is allowed to take
func (p *Parser) OperationLimit() int {
	return int(func() _Ctype_uint64_t{ _cgo0 := /*line :183:40*/p.c; _cgoCheckPointer(_cgo0, nil); return /*line :183:44*/_Cfunc_ts_parser_timeout_micros(_cgo0); }())
}

// SetOperationLimit limits the maximum duration in microseconds that parsing should be allowed to take before halting
func (p *Parser) SetOperationLimit(limit int) {
	func() { _cgo0 := /*line :188:33*/p.c; var _cgo1 _Ctype_uint64_t = _Ctype_uint64_t /*line :188:48*/(limit); _cgoCheckPointer(_cgo0, nil); /*line :188:56*/_Cfunc_ts_parser_set_timeout_micros(_cgo0, _cgo1); }()
}

// Reset causes the parser to parse from scratch on the next call to parse, instead of resuming
// so that it sees the changes to the beginning of the source code.
func (p *Parser) Reset() {
	func() { _cgo0 := /*line :194:20*/p.c; _cgoCheckPointer(_cgo0, nil); /*line :194:24*/_Cfunc_ts_parser_reset(_cgo0); }()
}

// SetIncludedRanges sets text ranges of a file
func (p *Parser) SetIncludedRanges(ranges []Range) {
	cRanges := make([] /*line :199:20*/_Ctype_TSRange /*line :199:29*/, len(ranges))
	for i, r := range ranges {
		cRanges[i] =  /*line :201:16*/_Ctype_TSRange /*line :201:25*/{
			start_point:  /*line :202:17*/_Ctype_TSPoint /*line :202:26*/{
				row:     /*line :203:13*/_Ctype_uint32_t /*line :203:23*/(r.StartPoint.Row),
				column:  /*line :204:13*/_Ctype_uint32_t /*line :204:23*/(r.StartPoint.Column),
			},
			end_point:  /*line :206:15*/_Ctype_TSPoint /*line :206:24*/{
				row:     /*line :207:13*/_Ctype_uint32_t /*line :207:23*/(r.EndPoint.Row),
				column:  /*line :208:13*/_Ctype_uint32_t /*line :208:23*/(r.EndPoint.Column),
			},
			start_byte:  /*line :210:16*/_Ctype_uint32_t /*line :210:26*/(r.StartByte),
			end_byte:    /*line :211:16*/_Ctype_uint32_t /*line :211:26*/(r.EndByte),
		}
	}
	func() _Ctype__Bool{ _cgo0 := /*line :214:34*/p.c; var _cgo1 *_Ctype_struct___6 = /*line :214:39*/(*_Ctype_TSRange /*line :214:50*/)(unsafe.Pointer(&cRanges[0])); var _cgo2 _Ctype_uint32_t = _Ctype_uint /*line :214:88*/(len(ranges)); _cgoCheckPointer(_cgo0, nil); return /*line :214:102*/_Cfunc_ts_parser_set_included_ranges(_cgo0, _cgo1, _cgo2); }()
}

// Debug enables debug output to stderr
func (p *Parser) Debug() {
	logger := ( /*line :219:12*/_Cfunc_stderr_logger_new /*line :219:30*/)(true)
	func() { _cgo0 := /*line :220:25*/p.c; _cgo1 := /*line :220:30*/logger; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :220:37*/_Cfunc_ts_parser_set_logger(_cgo0, _cgo1); }()
}

// Close should be called to ensure that all the memory used by the parse is freed.
//
// As the constructor in go-tree-sitter would set this func call through runtime.SetFinalizer,
// parser.Close() will be called by Go's garbage collector and users would not have to call this manually.
func (p *Parser) Close() {
	if !p.isClosed {
		func() { _cgo0 := /*line :229:22*/p.c; _cgoCheckPointer(_cgo0, nil); /*line :229:26*/_Cfunc_ts_parser_delete(_cgo0); }()
	}

	p.isClosed = true
}

type Point struct {
	Row    uint32
	Column uint32
}

type Range struct {
	StartPoint Point
	EndPoint   Point
	StartByte  uint32
	EndByte    uint32
}

// we use cache for nodes on normal tree object
// it prevent run of SetFinalizer as it introduces cycle
// we can workaround it using separate object
// for details see: https://github.com/golang/go/issues/7358#issuecomment-66091558
type BaseTree struct {
	c        * /*line :252:12*/_Ctype_TSTree /*line :252:20*/
	isClosed bool
}

// newTree creates a new tree object from a C pointer. The function will set a finalizer for the object,
// thus no free is needed for it.
func (p *Parser) newTree(c * /*line :258:29*/_Ctype_TSTree /*line :258:37*/) *Tree {
	base := &BaseTree{c: c}
	runtime.SetFinalizer(base, (*BaseTree).Close)

	newTree := &Tree{p: p, BaseTree: base, cache: make(map[ /*line :262:57*/_Ctype_TSNode /*line :262:65*/]*Node)}
	return newTree
}

// Tree represents the syntax tree of an entire source code file
// Note: Tree instances are not thread safe;
// you must copy a tree if you want to use it on multiple threads simultaneously.
type Tree struct {
	*BaseTree

	// p is a pointer to a Parser that produced the Tree. Only used to keep Parser alive.
	// Otherwise Parser may be GC'ed (and deleted by the finalizer) while some Tree objects are still in use.
	p *Parser

	// most probably better save node.id
	cache map[ /*line :277:12*/_Ctype_TSNode /*line :277:20*/]*Node
}

// Copy returns a new copy of a tree
func (t *Tree) Copy() *Tree {
	return t.p.newTree(func() *_Ctype_struct_TSTree{ _cgo0 := /*line :282:36*/t.c; _cgoCheckPointer(_cgo0, nil); return /*line :282:40*/_Cfunc_ts_tree_copy(_cgo0); }())
}

// RootNode returns root node of a tree
func (t *Tree) RootNode() *Node {
	ptr := func() _Ctype_struct___2{ _cgo0 := /*line :287:29*/t.c; _cgoCheckPointer(_cgo0, nil); return /*line :287:33*/_Cfunc_ts_tree_root_node(_cgo0); }()
	return t.cachedNode(ptr)
}

func (t *Tree) cachedNode(ptr  /*line :291:31*/_Ctype_TSNode /*line :291:39*/) *Node {
	if ptr.id == nil {
		return nil
	}

	if n, ok := t.cache[ptr]; ok {
		return n
	}

	n := &Node{ptr, t}
	t.cache[ptr] = n
	return n
}

// Close should be called to ensure that all the memory used by the tree is freed.
//
// As the constructor in go-tree-sitter would set this func call through runtime.SetFinalizer,
// parser.Close() will be called by Go's garbage collector and users would not have to call this manually.
func (t *BaseTree) Close() {
	if !t.isClosed {
		func() { _cgo0 := /*line :311:20*/t.c; _cgoCheckPointer(_cgo0, nil); /*line :311:24*/_Cfunc_ts_tree_delete(_cgo0); }()
	}

	t.isClosed = true
}

type EditInput struct {
	StartIndex  uint32
	OldEndIndex uint32
	NewEndIndex uint32
	StartPoint  Point
	OldEndPoint Point
	NewEndPoint Point
}

func (i EditInput) c() * /*line :326:25*/_Ctype_TSInputEdit /*line :326:38*/ {
	return & /*line :327:10*/_Ctype_TSInputEdit /*line :327:23*/{
		start_byte:    /*line :328:17*/_Ctype_uint32_t /*line :328:27*/(i.StartIndex),
		old_end_byte:  /*line :329:17*/_Ctype_uint32_t /*line :329:27*/(i.OldEndIndex),
		new_end_byte:  /*line :330:17*/_Ctype_uint32_t /*line :330:27*/(i.NewEndIndex),
		start_point:  /*line :331:16*/_Ctype_TSPoint /*line :331:25*/{
			row:     /*line :332:12*/_Ctype_uint32_t /*line :332:22*/(i.StartPoint.Row),
			column:  /*line :333:12*/_Ctype_uint32_t /*line :333:22*/(i.StartPoint.Column),
		},
		old_end_point:  /*line :335:18*/_Ctype_TSPoint /*line :335:27*/{
			row:     /*line :336:12*/_Ctype_uint32_t /*line :336:22*/(i.OldEndPoint.Row),
			column:  /*line :337:12*/_Ctype_uint32_t /*line :337:22*/(i.OldEndPoint.Column),
		},
		new_end_point:  /*line :339:18*/_Ctype_TSPoint /*line :339:27*/{
			row:     /*line :340:12*/_Ctype_uint32_t /*line :340:22*/(i.OldEndPoint.Row),
			column:  /*line :341:12*/_Ctype_uint32_t /*line :341:22*/(i.OldEndPoint.Column),
		},
	}
}

// Edit the syntax tree to keep it in sync with source code that has been edited.
func (t *Tree) Edit(i EditInput) {
	func() { _cgo0 := /*line :348:17*/t.c; var _cgo1 *_Ctype_struct___0 = /*line :348:22*/i.c(); _cgoCheckPointer(_cgo0, nil); /*line :348:28*/_Cfunc_ts_tree_edit(_cgo0, _cgo1); }()
}

// Language defines how to parse a particular programming language
type Language struct {
	ptr unsafe.Pointer
}

// NewLanguage creates new Language from c pointer
func NewLanguage(ptr unsafe.Pointer) *Language {
	return &Language{ptr}
}

// SymbolName returns a node type string for the given Symbol.
func (l *Language) SymbolName(s Symbol) string {
	return ( /*line :363:9*/_Cfunc_GoString /*line :363:18*/)(func() *_Ctype_char{ _cgo0 := /*line :363:46*/(*_Ctype_TSLanguage /*line :363:60*/)(l.ptr); var _cgo1 _Ctype_TSSymbol = /*line :363:70*/s; _cgoCheckPointer(_cgo0, nil); return /*line :363:72*/_Cfunc_ts_language_symbol_name(_cgo0, _cgo1); }())
}

// SymbolType returns named, anonymous, or a hidden type for a Symbol.
func (l *Language) SymbolType(s Symbol) SymbolType {
	return SymbolType(func() _Ctype_TSSymbolType{ _cgo0 := /*line :368:46*/(*_Ctype_TSLanguage /*line :368:60*/)(l.ptr); var _cgo1 _Ctype_TSSymbol = /*line :368:70*/s; _cgoCheckPointer(_cgo0, nil); return /*line :368:72*/_Cfunc_ts_language_symbol_type(_cgo0, _cgo1); }())
}

// SymbolCount returns the number of distinct field names in the language.
func (l *Language) SymbolCount() uint32 {
	return uint32(func() _Ctype_uint32_t{ _cgo0 := /*line :373:43*/(*_Ctype_TSLanguage /*line :373:57*/)(l.ptr); _cgoCheckPointer(_cgo0, nil); return /*line :373:66*/_Cfunc_ts_language_symbol_count(_cgo0); }())
}

func (l *Language) FieldName(idx int) string {
	return ( /*line :377:9*/_Cfunc_GoString /*line :377:18*/)(func() *_Ctype_char{ _cgo0 := /*line :377:52*/(*_Ctype_TSLanguage /*line :377:66*/)(l.ptr); var _cgo1 _Ctype_TSFieldId = _Ctype_ushort /*line :377:84*/(idx); _cgoCheckPointer(_cgo0, nil); return /*line :377:90*/_Cfunc_ts_language_field_name_for_id(_cgo0, _cgo1); }())
}

// Node represents a single node in the syntax tree
// It tracks its start and end positions in the source code,
// as well as its relation to other nodes like its parent, siblings and children.
type Node struct {
	c  /*line :384:4*/_Ctype_TSNode /*line :384:12*/
	t *Tree // keep pointer on tree because node is valid only as long as tree is
}

type Symbol =  /*line :388:15*/_Ctype_TSSymbol /*line :388:25*/

type SymbolType int

const (
	SymbolTypeRegular SymbolType = iota
	SymbolTypeAnonymous
	SymbolTypeAuxiliary
)

var symbolTypeNames = []string{
	"Regular",
	"Anonymous",
	"Auxiliary",
}

func (t SymbolType) String() string {
	return symbolTypeNames[t]
}

// StartByte returns the node's start byte.
func (n Node) StartByte() uint32 {
	return uint32(func() _Ctype_uint32_t{ _cgo0 := /*line :410:37*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :410:41*/_Cfunc_ts_node_start_byte(_cgo0); }())
}

// EndByte returns the node's end byte.
func (n Node) EndByte() uint32 {
	return uint32(func() _Ctype_uint32_t{ _cgo0 := /*line :415:35*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :415:39*/_Cfunc_ts_node_end_byte(_cgo0); }())
}

// StartPoint returns the node's start position in terms of rows and columns.
func (n Node) StartPoint() Point {
	p := func() _Ctype_struct___1{ _cgo0 := /*line :420:29*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :420:33*/_Cfunc_ts_node_start_point(_cgo0); }()
	return Point{
		Row:    uint32(p.row),
		Column: uint32(p.column),
	}
}

// EndPoint returns the node's end position in terms of rows and columns.
func (n Node) EndPoint() Point {
	p := func() _Ctype_struct___1{ _cgo0 := /*line :429:27*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :429:31*/_Cfunc_ts_node_end_point(_cgo0); }()
	return Point{
		Row:    uint32(p.row),
		Column: uint32(p.column),
	}
}

// Symbol returns the node's type as a Symbol.
func (n Node) Symbol() Symbol {
	return func() _Ctype_TSSymbol{ _cgo0 := /*line :438:26*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :438:30*/_Cfunc_ts_node_symbol(_cgo0); }()
}

// Type returns the node's type as a string.
func (n Node) Type() string {
	return ( /*line :443:9*/_Cfunc_GoString /*line :443:18*/)(func() *_Ctype_char{ _cgo0 := /*line :443:35*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :443:39*/_Cfunc_ts_node_type(_cgo0); }())
}

// String returns an S-expression representing the node as a string.
func (n Node) String() string {
	ptr := func() *_Ctype_char{ _cgo0 := /*line :448:26*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :448:30*/_Cfunc_ts_node_string(_cgo0); }()
	defer func() func() { _cgo0 := /*line :449:15*/unsafe.Pointer(ptr); return func() { _cgoCheckPointer(_cgo0, nil); /*line :449:35*/_Cfunc_free(_cgo0); }}()()
	return ( /*line :450:9*/_Cfunc_GoString /*line :450:18*/)(ptr)
}

// Equal checks if two nodes are identical.
func (n Node) Equal(other *Node) bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :455:27*/n.c; _cgo1 := /*line :455:32*/other.c; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :455:40*/_Cfunc_ts_node_eq(_cgo0, _cgo1); }())
}

// IsNull checks if the node is null.
func (n Node) IsNull() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :460:32*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :460:36*/_Cfunc_ts_node_is_null(_cgo0); }())
}

// IsNamed checks if the node is *named*.
// Named nodes correspond to named rules in the grammar,
// whereas *anonymous* nodes correspond to string literals in the grammar.
func (n Node) IsNamed() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :467:33*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :467:37*/_Cfunc_ts_node_is_named(_cgo0); }())
}

// IsMissing checks if the node is *missing*.
// Missing nodes are inserted by the parser in order to recover from certain kinds of syntax errors.
func (n Node) IsMissing() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :473:35*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :473:39*/_Cfunc_ts_node_is_missing(_cgo0); }())
}

// IsExtra checks if the node is *extra*.
// Extra nodes represent things like comments, which are not required the grammar, but can appear anywhere.
func (n Node) IsExtra() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :479:33*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :479:37*/_Cfunc_ts_node_is_extra(_cgo0); }())
}

// IsError checks if the node is a syntax error.
// Syntax errors represent parts of the code that could not be incorporated into a valid syntax tree.
func (n Node) IsError() bool {
	return n.Symbol() == math.MaxUint16
}

// HasChanges checks if a syntax node has been edited.
func (n Node) HasChanges() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :490:36*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :490:40*/_Cfunc_ts_node_has_changes(_cgo0); }())
}

// HasError check if the node is a syntax error or contains any syntax errors.
func (n Node) HasError() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :495:34*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :495:38*/_Cfunc_ts_node_has_error(_cgo0); }())
}

// Parent returns the node's immediate parent.
func (n Node) Parent() *Node {
	nn := func() _Ctype_struct___2{ _cgo0 := /*line :500:25*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :500:29*/_Cfunc_ts_node_parent(_cgo0); }()
	return n.t.cachedNode(nn)
}

// Child returns the node's child at the given index, where zero represents the first child.
func (n Node) Child(idx int) *Node {
	nn := func() _Ctype_struct___2{ _cgo0 := /*line :506:24*/n.c; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :506:39*/(idx); _cgoCheckPointer(_cgo0, nil); return /*line :506:45*/_Cfunc_ts_node_child(_cgo0, _cgo1); }()
	return n.t.cachedNode(nn)
}

// NamedChild returns the node's *named* child at the given index.
func (n Node) NamedChild(idx int) *Node {
	nn := func() _Ctype_struct___2{ _cgo0 := /*line :512:30*/n.c; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :512:45*/(idx); _cgoCheckPointer(_cgo0, nil); return /*line :512:51*/_Cfunc_ts_node_named_child(_cgo0, _cgo1); }()
	return n.t.cachedNode(nn)
}

// ChildCount returns the node's number of children.
func (n Node) ChildCount() uint32 {
	return uint32(func() _Ctype_uint32_t{ _cgo0 := /*line :518:38*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :518:42*/_Cfunc_ts_node_child_count(_cgo0); }())
}

// NamedChildCount returns the node's number of *named* children.
func (n Node) NamedChildCount() uint32 {
	return uint32(func() _Ctype_uint32_t{ _cgo0 := /*line :523:44*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :523:48*/_Cfunc_ts_node_named_child_count(_cgo0); }())
}

// ChildByFieldName returns the node's child with the given field name.
func (n Node) ChildByFieldName(name string) *Node {
	str := ( /*line :528:9*/_Cfunc_CString /*line :528:17*/)(name)
	defer func() func() { _cgo0 := /*line :529:15*/unsafe.Pointer(str); return func() { _cgoCheckPointer(_cgo0, nil); /*line :529:35*/_Cfunc_free(_cgo0); }}()()
	nn := func() _Ctype_struct___2{ _cgo0 := /*line :530:38*/n.c; var _cgo1 *_Ctype_char = /*line :530:43*/str; var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t /*line :530:58*/(len(name)); _cgoCheckPointer(_cgo0, nil); return /*line :530:70*/_Cfunc_ts_node_child_by_field_name(_cgo0, _cgo1, _cgo2); }()
	return n.t.cachedNode(nn)
}

// FieldNameForChild returns the field name of the child at the given index, or "" if not named.
func (n Node) FieldNameForChild(idx int) string {
	return ( /*line :536:9*/_Cfunc_GoString /*line :536:18*/)(func() *_Ctype_char{ _cgo0 := /*line :536:51*/n.c; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :536:66*/(idx); _cgoCheckPointer(_cgo0, nil); return /*line :536:72*/_Cfunc_ts_node_field_name_for_child(_cgo0, _cgo1); }())
}

// NextSibling returns the node's next sibling.
func (n Node) NextSibling() *Node {
	nn := func() _Ctype_struct___2{ _cgo0 := /*line :541:31*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :541:35*/_Cfunc_ts_node_next_sibling(_cgo0); }()
	return n.t.cachedNode(nn)
}

// NextNamedSibling returns the node's next *named* sibling.
func (n Node) NextNamedSibling() *Node {
	nn := func() _Ctype_struct___2{ _cgo0 := /*line :547:37*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :547:41*/_Cfunc_ts_node_next_named_sibling(_cgo0); }()
	return n.t.cachedNode(nn)
}

// PrevSibling returns the node's previous sibling.
func (n Node) PrevSibling() *Node {
	nn := func() _Ctype_struct___2{ _cgo0 := /*line :553:31*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :553:35*/_Cfunc_ts_node_prev_sibling(_cgo0); }()
	return n.t.cachedNode(nn)
}

// PrevNamedSibling returns the node's previous *named* sibling.
func (n Node) PrevNamedSibling() *Node {
	nn := func() _Ctype_struct___2{ _cgo0 := /*line :559:37*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :559:41*/_Cfunc_ts_node_prev_named_sibling(_cgo0); }()
	return n.t.cachedNode(nn)
}

// Edit the node to keep it in-sync with source code that has been edited.
func (n Node) Edit(i EditInput) {
	func() { _cgoBase0 := /*line :565:17*/&n.c; _cgo0 := _cgoBase0; var _cgo1 *_Ctype_struct___0 = /*line :565:23*/i.c(); _cgoCheckPointer(_cgoBase0, 0 == 0); /*line :565:29*/_Cfunc_ts_node_edit(_cgo0, _cgo1); }()
}

// Content returns node's source code from input as a string
func (n Node) Content(input []byte) string {
	return string(input[n.StartByte():n.EndByte()])
}

func (n Node) NamedDescendantForPointRange(start Point, end Point) *Node {
	cStartPoint :=  /*line :574:17*/_Ctype_TSPoint /*line :574:26*/{
		row:     /*line :575:11*/_Ctype_uint32_t /*line :575:21*/(start.Row),
		column:  /*line :576:11*/_Ctype_uint32_t /*line :576:21*/(start.Column),
	}
	cEndPoint :=  /*line :578:15*/_Ctype_TSPoint /*line :578:24*/{
		row:     /*line :579:11*/_Ctype_uint32_t /*line :579:21*/(end.Row),
		column:  /*line :580:11*/_Ctype_uint32_t /*line :580:21*/(end.Column),
	}
	nn := func() _Ctype_struct___2{ _cgo0 := /*line :582:51*/n.c; var _cgo1 _Ctype_struct___1 = /*line :582:56*/cStartPoint; var _cgo2 _Ctype_struct___1 = /*line :582:69*/cEndPoint; _cgoCheckPointer(_cgo0, nil); return /*line :582:79*/_Cfunc_ts_node_named_descendant_for_point_range(_cgo0, _cgo1, _cgo2); }()
	return n.t.cachedNode(nn)
}

// TreeCursor allows you to walk a syntax tree more efficiently than is
// possible using the `Node` functions. It is a mutable object that is always
// on a certain syntax node, and can be moved imperatively to different nodes.
type TreeCursor struct {
	c * /*line :590:5*/_Ctype_TSTreeCursor /*line :590:19*/
	t *Tree

	isClosed bool
}

// NewTreeCursor creates a new tree cursor starting from the given node.
func NewTreeCursor(n *Node) *TreeCursor {
	cc := func() _Ctype_struct___7{ _cgo0 := /*line :598:29*/n.c; _cgoCheckPointer(_cgo0, nil); return /*line :598:33*/_Cfunc_ts_tree_cursor_new(_cgo0); }()
	c := &TreeCursor{
		c: &cc,
		t: n.t,
	}

	runtime.SetFinalizer(c, (*TreeCursor).Close)
	return c
}

// Close should be called to ensure that all the memory used by the tree cursor
// is freed.
//
// As the constructor in go-tree-sitter would set this func call through runtime.SetFinalizer,
// parser.Close() will be called by Go's garbage collector and users would not have to call this manually.
func (c *TreeCursor) Close() {
	if !c.isClosed {
		func() { _cgo0 := /*line :615:27*/c.c; _cgoCheckPointer(_cgo0, nil); /*line :615:31*/_Cfunc_ts_tree_cursor_delete(_cgo0); }()
	}

	c.isClosed = true
}

// Reset re-initializes a tree cursor to start at a different node.
func (c *TreeCursor) Reset(n *Node) {
	c.t = n.t
	func() { _cgo0 := /*line :624:25*/c.c; _cgo1 := /*line :624:30*/n.c; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :624:34*/_Cfunc_ts_tree_cursor_reset(_cgo0, _cgo1); }()
}

// CurrentNode of the tree cursor.
func (c *TreeCursor) CurrentNode() *Node {
	n := func() _Ctype_struct___2{ _cgo0 := /*line :629:37*/c.c; _cgoCheckPointer(_cgo0, nil); return /*line :629:41*/_Cfunc_ts_tree_cursor_current_node(_cgo0); }()
	return c.t.cachedNode(n)
}

// CurrentFieldName gets the field name of the tree cursor's current node.
//
// This returns empty string if the current node doesn't have a field.
func (c *TreeCursor) CurrentFieldName() string {
	return ( /*line :637:9*/_Cfunc_GoString /*line :637:18*/)(func() *_Ctype_char{ _cgo0 := /*line :637:56*/c.c; _cgoCheckPointer(_cgo0, nil); return /*line :637:60*/_Cfunc_ts_tree_cursor_current_field_name(_cgo0); }())
}

// GoToParent moves the cursor to the parent of its current node.
//
// This returns `true` if the cursor successfully moved, and returns `false`
// if there was no parent node (the cursor was already on the root node).
func (c *TreeCursor) GoToParent() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :645:43*/c.c; _cgoCheckPointer(_cgo0, nil); return /*line :645:47*/_Cfunc_ts_tree_cursor_goto_parent(_cgo0); }())
}

// GoToNextSibling moves the cursor to the next sibling of its current node.
//
// This returns `true` if the cursor successfully moved, and returns `false`
// if there was no next sibling node.
func (c *TreeCursor) GoToNextSibling() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :653:49*/c.c; _cgoCheckPointer(_cgo0, nil); return /*line :653:53*/_Cfunc_ts_tree_cursor_goto_next_sibling(_cgo0); }())
}

// GoToFirstChild moves the cursor to the first child of its current node.
//
// This returns `true` if the cursor successfully moved, and returns `false`
// if there were no children.
func (c *TreeCursor) GoToFirstChild() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :661:48*/c.c; _cgoCheckPointer(_cgo0, nil); return /*line :661:52*/_Cfunc_ts_tree_cursor_goto_first_child(_cgo0); }())
}

// GoToFirstChildForByte moves the cursor to the first child of its current node
// that extends beyond the given byte offset.
//
// This returns the index of the child node if one was found, and returns -1
// if no such child was found.
func (c *TreeCursor) GoToFirstChildForByte(b uint32) int64 {
	return int64(func() _Ctype_int64_t{ _cgo0 := /*line :670:58*/c.c; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :670:73*/(b); _cgoCheckPointer(_cgo0, nil); return /*line :670:77*/_Cfunc_ts_tree_cursor_goto_first_child_for_byte(_cgo0, _cgo1); }())
}

// QueryErrorType - value that indicates the type of QueryError.
type QueryErrorType int

const (
	QueryErrorNone QueryErrorType = iota
	QueryErrorSyntax
	QueryErrorNodeType
	QueryErrorField
	QueryErrorCapture
	QueryErrorStructure
	QueryErrorLanguage
)

func QueryErrorTypeToString(errorType QueryErrorType) string {
	switch errorType {
	case QueryErrorNone:
		return "none"
	case QueryErrorNodeType:
		return "node type"
	case QueryErrorField:
		return "field"
	case QueryErrorCapture:
		return "capture"
	case QueryErrorSyntax:
		return "syntax"
	default:
		return "unknown"
	}

}

// QueryError - if there is an error in the query,
// then the Offset argument will be set to the byte offset of the error,
// and the Type argument will be set to a value that indicates the type of error.
type QueryError struct {
	Offset  uint32
	Type    QueryErrorType
	Message string
}

func (qe *QueryError) Error() string {
	return qe.Message
}

// Query API
type Query struct {
	c        * /*line :719:12*/_Ctype_TSQuery /*line :719:21*/
	isClosed bool
}

// NewQuery creates a query by specifying a string containing one or more patterns.
// In case of error returns QueryError.
func NewQuery(pattern []byte, lang *Language) (*Query, error) {
	var (
		erroff   /*line :727:11*/_Ctype_uint32_t /*line :727:21*/
		errtype  /*line :728:11*/_Ctype_TSQueryError /*line :728:25*/
	)

	input := func() _cgo_unsafe.Pointer{ _cgo0 := /*line :731:20*/pattern; _cgoCheckPointer(_cgo0, nil); return /*line :731:28*/_Cfunc_CBytes(_cgo0); }()
	c := func() *_Ctype_struct_TSQuery{ _cgo0 := /*line :733:3*/(*_Ctype_struct_TSLanguage /*line :733:24*/)(lang.ptr); var _cgo1 *_Ctype_char = /*line :734:3*/(*_Ctype_char /*line :734:11*/)(input); var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t /*line :735:13*/(len(pattern)); var _cgo3 *_Ctype_uint32_t = /*line :736:3*/&erroff; var _cgo4 *_Ctype_TSQueryError = /*line :737:3*/&errtype; _cgoCheckPointer(_cgo0, nil); return /*line :738:3*/_Cfunc_ts_query_new(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	func() { _cgo0 := /*line :739:9*/input; _cgoCheckPointer(_cgo0, nil); /*line :739:15*/_Cfunc_free(_cgo0); }()
	if errtype !=  /*line :740:16*/_Ctype_TSQueryError /*line :740:30*/(QueryErrorNone) {
		errorOffset := uint32(erroff)
		// search for the line containing the offset
		line := 1
		line_start := 0
		for i, c := range pattern {
			line_start = i
			if uint32(i) >= errorOffset {
				break
			}
			if c == '\n' {
				line++
			}
		}
		column := int(errorOffset) - line_start
		errorType := QueryErrorType(errtype)
		errorTypeToString := QueryErrorTypeToString(errorType)

		var message string
		switch errorType {
		// errors that apply to a single identifier
		case QueryErrorNodeType:
			fallthrough
		case QueryErrorField:
			fallthrough
		case QueryErrorCapture:
			// find identifier at input[errorOffset]
			// and report it in the error message
			s := string(pattern[errorOffset:])
			identifierRegexp := regexp.MustCompile(`^[a-zA-Z_][a-zA-Z0-9_-]*`)
			m := identifierRegexp.FindStringSubmatch(s)
			if len(m) > 0 {
				message = fmt.Sprintf("invalid %s '%s' at line %d column %d",
					errorTypeToString, m[0], line, column)
			} else {
				message = fmt.Sprintf("invalid %s at line %d column %d",
					errorTypeToString, line, column)
			}

		// errors the report position
		case QueryErrorSyntax:
			fallthrough
		case QueryErrorStructure:
			fallthrough
		case QueryErrorLanguage:
			fallthrough
		default:
			s := string(pattern[errorOffset:])
			lines := strings.Split(s, "\n")
			whitespace := strings.Repeat(" ", column)
			message = fmt.Sprintf("invalid %s at line %d column %d\n%s\n%s^",
				errorTypeToString, line, column,
				lines[0], whitespace)
		}

		return nil, &QueryError{
			Offset:  errorOffset,
			Type:    errorType,
			Message: message,
		}
	}

	q := &Query{c: c}

	// Copied from: https://github.com/klothoplatform/go-tree-sitter/commit/e351b20167b26d515627a4a1a884528ede5fef79
	// this is just used for syntax validation - it does not actually filter anything
	for i := uint32(0); i < q.PatternCount(); i++ {
		predicates := q.PredicatesForPattern(i)
		for _, steps := range predicates {
			if len(steps) == 0 {
				continue
			}

			if steps[0].Type != QueryPredicateStepTypeString {
				return nil, errors.New("predicate must begin with a literal value")
			}

			operator := q.StringValueForId(steps[0].ValueId)
			switch operator {
			case "eq?", "not-eq?":
				if len(steps) != 4 {
					return nil, fmt.Errorf("wrong number of arguments to `#%s` predicate. Expected 2, got %d", operator, len(steps)-2)
				}
				if steps[1].Type != QueryPredicateStepTypeCapture {
					return nil, fmt.Errorf("first argument of `#%s` predicate must be a capture. Got %s", operator, q.StringValueForId(steps[1].ValueId))
				}
			case "match?", "not-match?":
				if len(steps) != 4 {
					return nil, fmt.Errorf("wrong number of arguments to `#%s` predicate. Expected 2, got %d", operator, len(steps)-2)
				}
				if steps[1].Type != QueryPredicateStepTypeCapture {
					return nil, fmt.Errorf("first argument of `#%s` predicate must be a capture. Got %s", operator, q.StringValueForId(steps[1].ValueId))
				}
				if steps[2].Type != QueryPredicateStepTypeString {
					return nil, fmt.Errorf("second argument of `#%s` predicate must be a string. Got %s", operator, q.StringValueForId(steps[2].ValueId))
				}
			case "set!", "is?", "is-not?":
				if len(steps) < 3 || len(steps) > 4 {
					return nil, fmt.Errorf("wrong number of arguments to `#%s` predicate. Expected 1 or 2, got %d", operator, len(steps)-2)
				}
				if steps[1].Type != QueryPredicateStepTypeString {
					return nil, fmt.Errorf("first argument of `#%s` predicate must be a string. Got %s", operator, q.StringValueForId(steps[1].ValueId))
				}
				if len(steps) > 2 && steps[2].Type != QueryPredicateStepTypeString {
					return nil, fmt.Errorf("second argument of `#%s` predicate must be a string. Got %s", operator, q.StringValueForId(steps[2].ValueId))
				}
			}
		}
	}

	runtime.SetFinalizer(q, (*Query).Close)

	return q, nil
}

// Close should be called to ensure that all the memory used by the query is freed.
//
// As the constructor in go-tree-sitter would set this func call through runtime.SetFinalizer,
// parser.Close() will be called by Go's garbage collector and users would not have to call this manually.
func (q *Query) Close() {
	if !q.isClosed {
		func() { _cgo0 := /*line :861:21*/q.c; _cgoCheckPointer(_cgo0, nil); /*line :861:25*/_Cfunc_ts_query_delete(_cgo0); }()
	}

	q.isClosed = true
}

func (q *Query) PatternCount() uint32 {
	return uint32(func() _Ctype_uint32_t{ _cgo0 := /*line :868:41*/q.c; _cgoCheckPointer(_cgo0, nil); return /*line :868:45*/_Cfunc_ts_query_pattern_count(_cgo0); }())
}

func (q *Query) CaptureCount() uint32 {
	return uint32(func() _Ctype_uint32_t{ _cgo0 := /*line :872:41*/q.c; _cgoCheckPointer(_cgo0, nil); return /*line :872:45*/_Cfunc_ts_query_capture_count(_cgo0); }())
}

func (q *Query) StringCount() uint32 {
	return uint32(func() _Ctype_uint32_t{ _cgo0 := /*line :876:40*/q.c; _cgoCheckPointer(_cgo0, nil); return /*line :876:44*/_Cfunc_ts_query_string_count(_cgo0); }())
}

type QueryPredicateStepType int

const (
	QueryPredicateStepTypeDone QueryPredicateStepType = iota
	QueryPredicateStepTypeCapture
	QueryPredicateStepTypeString
)

type QueryPredicateStep struct {
	Type    QueryPredicateStepType
	ValueId uint32
}

func (q *Query) PredicatesForPattern(patternIndex uint32) [][]QueryPredicateStep {
	var (
		length           /*line :894:19*/_Ctype_uint32_t /*line :894:29*/
		cPredicateSteps [] /*line :895:21*/_Ctype_TSQueryPredicateStep /*line :895:43*/
		predicateSteps  []QueryPredicateStep
	)

	cPredicateStep := func() *_Ctype_struct___5{ _cgo0 := /*line :899:54*/q.c; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :899:69*/(patternIndex); var _cgo2 *_Ctype_uint32_t = /*line :899:85*/&length; _cgoCheckPointer(_cgo0, nil); return /*line :899:93*/_Cfunc_ts_query_predicates_for_pattern(_cgo0, _cgo1, _cgo2); }()

	count := int(length)
	slice := (*reflect.SliceHeader)((unsafe.Pointer(&cPredicateSteps)))
	slice.Cap = count
	slice.Len = count
	slice.Data = uintptr(unsafe.Pointer(cPredicateStep))
	for _, s := range cPredicateSteps {
		stepType := QueryPredicateStepType(s._type)
		valueId := uint32(s.value_id)
		predicateSteps = append(predicateSteps, QueryPredicateStep{stepType, valueId})
	}

	return splitPredicates(predicateSteps)
}

func (q *Query) CaptureNameForId(id uint32) string {
	var length  /*line :916:13*/_Ctype_uint32_t /*line :916:23*/
	name := func() *_Ctype_char{ _cgo0 := /*line :917:41*/q.c; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :917:56*/(id); var _cgo2 *_Ctype_uint32_t = /*line :917:62*/&length; _cgoCheckPointer(_cgo0, nil); return /*line :917:70*/_Cfunc_ts_query_capture_name_for_id(_cgo0, _cgo1, _cgo2); }()
	return ( /*line :918:9*/_Cfunc_GoStringN /*line :918:19*/)(name,  /*line :918:27*/_Ctype_int /*line :918:32*/(length))
}

func (q *Query) StringValueForId(id uint32) string {
	var length  /*line :922:13*/_Ctype_uint32_t /*line :922:23*/
	value := func() *_Ctype_char{ _cgo0 := /*line :923:42*/q.c; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :923:57*/(id); var _cgo2 *_Ctype_uint32_t = /*line :923:63*/&length; _cgoCheckPointer(_cgo0, nil); return /*line :923:71*/_Cfunc_ts_query_string_value_for_id(_cgo0, _cgo1, _cgo2); }()
	return ( /*line :924:9*/_Cfunc_GoStringN /*line :924:19*/)(value,  /*line :924:28*/_Ctype_int /*line :924:33*/(length))
}

type Quantifier int

const (
	QuantifierZero = iota
	QuantifierZeroOrOne
	QuantifierZeroOrMore
	QuantifierOne
	QuantifierOneOrMore
)

func (q *Query) CaptureQuantifierForId(id uint32, captureId uint32) Quantifier {
	return Quantifier(func() _Ctype_TSQuantifier{ _cgo0 := /*line :938:57*/q.c; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :938:72*/(id); var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t /*line :938:88*/(captureId); _cgoCheckPointer(_cgo0, nil); return /*line :938:100*/_Cfunc_ts_query_capture_quantifier_for_id(_cgo0, _cgo1, _cgo2); }())
}

// QueryCursor carries the state needed for processing the queries.
type QueryCursor struct {
	c * /*line :943:5*/_Ctype_TSQueryCursor /*line :943:20*/
	t *Tree
	// keep a pointer to the query to avoid garbage collection
	q *Query

	isClosed bool
}

// NewQueryCursor creates a query cursor.
func NewQueryCursor() *QueryCursor {
	qc := &QueryCursor{c: ( /*line :953:24*/_Cfunc_ts_query_cursor_new /*line :953:44*/)(), t: nil}
	runtime.SetFinalizer(qc, (*QueryCursor).Close)

	return qc
}

// Exec executes the query on a given syntax node.
func (qc *QueryCursor) Exec(q *Query, n *Node) {
	qc.q = q
	qc.t = n.t
	func() { _cgo0 := /*line :963:25*/qc.c; _cgo1 := /*line :963:31*/q.c; _cgo2 := /*line :963:36*/n.c; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); /*line :963:40*/_Cfunc_ts_query_cursor_exec(_cgo0, _cgo1, _cgo2); }()
}

func (qc *QueryCursor) SetPointRange(startPoint Point, endPoint Point) {
	cStartPoint :=  /*line :967:17*/_Ctype_TSPoint /*line :967:26*/{
		row:     /*line :968:11*/_Ctype_uint32_t /*line :968:21*/(startPoint.Row),
		column:  /*line :969:11*/_Ctype_uint32_t /*line :969:21*/(startPoint.Column),
	}
	cEndPoint :=  /*line :971:15*/_Ctype_TSPoint /*line :971:24*/{
		row:     /*line :972:11*/_Ctype_uint32_t /*line :972:21*/(endPoint.Row),
		column:  /*line :973:11*/_Ctype_uint32_t /*line :973:21*/(endPoint.Column),
	}
	func() { _cgo0 := /*line :975:36*/qc.c; var _cgo1 _Ctype_struct___1 = /*line :975:42*/cStartPoint; var _cgo2 _Ctype_struct___1 = /*line :975:55*/cEndPoint; _cgoCheckPointer(_cgo0, nil); /*line :975:65*/_Cfunc_ts_query_cursor_set_point_range(_cgo0, _cgo1, _cgo2); }()
}

// Close should be called to ensure that all the memory used by the query cursor is freed.
//
// As the constructor in go-tree-sitter would set this func call through runtime.SetFinalizer,
// parser.Close() will be called by Go's garbage collector and users would not have to call this manually.
func (qc *QueryCursor) Close() {
	if !qc.isClosed {
		func() { _cgo0 := /*line :984:28*/qc.c; _cgoCheckPointer(_cgo0, nil); /*line :984:33*/_Cfunc_ts_query_cursor_delete(_cgo0); }()
	}

	qc.isClosed = true
}

// QueryCapture is a captured node by a query with an index
type QueryCapture struct {
	Index uint32
	Node  *Node
}

// QueryMatch - you can then iterate over the matches.
type QueryMatch struct {
	ID           uint32
	PatternIndex uint16
	Captures     []QueryCapture
}

// NextMatch iterates over matches.
// This function will return (nil, false) when there are no more matches.
// Otherwise, it will populate the QueryMatch with data
// about which pattern matched and which nodes were captured.
func (qc *QueryCursor) NextMatch() (*QueryMatch, bool) {
	var (
		cqm  /*line :1009:7*/_Ctype_TSQueryMatch /*line :1009:21*/
		cqc [] /*line :1010:9*/_Ctype_TSQueryCapture /*line :1010:25*/
	)

	if ok := func() _Ctype__Bool{ _cgo0 := /*line :1013:40*/qc.c; _cgoBase1 := /*line :1013:46*/&cqm; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :1013:51*/_Cfunc_ts_query_cursor_next_match(_cgo0, _cgo1); }(); !bool(ok) {
		return nil, false
	}

	qm := &QueryMatch{
		ID:           uint32(cqm.id),
		PatternIndex: uint16(cqm.pattern_index),
	}

	count := int(cqm.capture_count)
	slice := (*reflect.SliceHeader)((unsafe.Pointer(&cqc)))
	slice.Cap = count
	slice.Len = count
	slice.Data = uintptr(unsafe.Pointer(cqm.captures))
	for _, c := range cqc {
		idx := uint32(c.index)
		node := qc.t.cachedNode(c.node)
		qm.Captures = append(qm.Captures, QueryCapture{idx, node})
	}

	return qm, true
}

func (qc *QueryCursor) NextCapture() (*QueryMatch, uint32, bool) {
	var (
		cqm           /*line :1038:16*/_Ctype_TSQueryMatch /*line :1038:30*/
		cqc          [] /*line :1039:18*/_Ctype_TSQueryCapture /*line :1039:34*/
		captureIndex  /*line :1040:16*/_Ctype_uint32_t /*line :1040:26*/
	)

	if ok := func() _Ctype__Bool{ _cgo0 := /*line :1043:42*/qc.c; _cgoBase1 := /*line :1043:48*/&cqm; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :1043:54*/&captureIndex; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :1043:68*/_Cfunc_ts_query_cursor_next_capture(_cgo0, _cgo1, _cgo2); }(); !bool(ok) {
		return nil, 0, false
	}

	qm := &QueryMatch{
		ID:           uint32(cqm.id),
		PatternIndex: uint16(cqm.pattern_index),
	}

	count := int(cqm.capture_count)
	slice := (*reflect.SliceHeader)((unsafe.Pointer(&cqc)))
	slice.Cap = count
	slice.Len = count
	slice.Data = uintptr(unsafe.Pointer(cqm.captures))
	for _, c := range cqc {
		idx := uint32(c.index)
		node := qc.t.cachedNode(c.node)
		qm.Captures = append(qm.Captures, QueryCapture{idx, node})
	}

	return qm, uint32(captureIndex), true
}

// Copied From: https://github.com/klothoplatform/go-tree-sitter/commit/e351b20167b26d515627a4a1a884528ede5fef79

func splitPredicates(steps []QueryPredicateStep) [][]QueryPredicateStep {
	var predicateSteps [][]QueryPredicateStep
	var currentSteps []QueryPredicateStep
	for _, step := range steps {
		currentSteps = append(currentSteps, step)
		if step.Type == QueryPredicateStepTypeDone {
			predicateSteps = append(predicateSteps, currentSteps)
			currentSteps = []QueryPredicateStep{}
		}
	}
	return predicateSteps
}

func (qc *QueryCursor) FilterPredicates(m *QueryMatch, input []byte) *QueryMatch {
	qm := &QueryMatch{
		ID:           m.ID,
		PatternIndex: m.PatternIndex,
	}

	q := qc.q

	predicates := q.PredicatesForPattern(uint32(qm.PatternIndex))
	if len(predicates) == 0 {
		qm.Captures = m.Captures
		return qm
	}

	// track if we matched all predicates globally
	matchedAll := true

	// check each predicate against the match
	for _, steps := range predicates {
		operator := q.StringValueForId(steps[0].ValueId)

		switch operator {
		case "eq?", "not-eq?":
			isPositive := operator == "eq?"

			expectedCaptureNameLeft := q.CaptureNameForId(steps[1].ValueId)

			if steps[2].Type == QueryPredicateStepTypeCapture {
				expectedCaptureNameRight := q.CaptureNameForId(steps[2].ValueId)

				var nodeLeft, nodeRight *Node

				for _, c := range m.Captures {
					captureName := q.CaptureNameForId(c.Index)

					if captureName == expectedCaptureNameLeft {
						nodeLeft = c.Node
					}
					if captureName == expectedCaptureNameRight {
						nodeRight = c.Node
					}

					if nodeLeft != nil && nodeRight != nil {
						if (nodeLeft.Content(input) == nodeRight.Content(input)) != isPositive {
							matchedAll = false
						}
						break
					}
				}
			} else {
				expectedValueRight := q.StringValueForId(steps[2].ValueId)

				for _, c := range m.Captures {
					captureName := q.CaptureNameForId(c.Index)

					if expectedCaptureNameLeft != captureName {
						continue
					}

					if (c.Node.Content(input) == expectedValueRight) != isPositive {
						matchedAll = false
						break
					}
				}
			}

			if matchedAll == false {
				break
			}

		case "match?", "not-match?":
			isPositive := operator == "match?"

			expectedCaptureName := q.CaptureNameForId(steps[1].ValueId)
			regex := regexp.MustCompile(q.StringValueForId(steps[2].ValueId))

			for _, c := range m.Captures {
				captureName := q.CaptureNameForId(c.Index)
				if expectedCaptureName != captureName {
					continue
				}

				if regex.Match([]byte(c.Node.Content(input))) != isPositive {
					matchedAll = false
					break
				}
			}
		}
	}

	if matchedAll {
		qm.Captures = append(qm.Captures, m.Captures...)
	}

	return qm

}

// keeps callbacks for parser.parse method
type readFuncsMap struct {
	sync.Mutex

	funcs map[int]ReadFunc
	count int
}

func (m *readFuncsMap) register(f ReadFunc) int {
	m.Lock()
	defer m.Unlock()

	m.count++
	m.funcs[m.count] = f
	return m.count
}

func (m *readFuncsMap) unregister(id int) {
	m.Lock()
	defer m.Unlock()

	delete(m.funcs, id)
}

func (m *readFuncsMap) get(id int) ReadFunc {
	m.Lock()
	defer m.Unlock()

	return m.funcs[id]
}

//export callReadFunc
func callReadFunc(id  /*line :1211:22*/_Ctype_int /*line :1211:27*/, byteIndex  /*line :1211:39*/_Ctype_uint32_t /*line :1211:49*/, position  /*line :1211:60*/_Ctype_TSPoint /*line :1211:69*/, bytesRead * /*line :1211:82*/_Ctype_uint32_t /*line :1211:92*/) * /*line :1211:95*/_Ctype_char /*line :1211:101*/ {
	readFunc := readFuncs.get(int(id))
	content := readFunc(uint32(byteIndex), Point{
		Row:    uint32(position.row),
		Column: uint32(position.column),
	})
	*bytesRead =  /*line :1217:15*/_Ctype_uint32_t /*line :1217:25*/(len(content))

	// Note: This memory is freed inside the C code; see bindings.c
	input := func() _cgo_unsafe.Pointer{ _cgo0 := /*line :1220:20*/content; _cgoCheckPointer(_cgo0, nil); return /*line :1220:28*/_Cfunc_CBytes(_cgo0); }()
	return (* /*line :1221:11*/_Ctype_char /*line :1221:17*/)(input)
}
